# 题目结构

|  题目  |   类型   | 分值  |
| :----: | :------: | :---: |
| 第一题 | 结果填空 | 11分  |
| 第二题 | 结果填空 | 35分  |
| 第三题 | 代码填空 | 27分  |
| 第四题 | 程序设计 | 45分  |
| 第五题 | 程序设计 | 77分  |
| 第六题 | 程序设计 | 105分 |



****

# 第一题 换零钞

* **题面**

  >x星球的钞票的面额只有：100元，5元，2元，1元，共4种。
  >小明去x星旅游，他手里只有2张100元的x星币，太不方便，恰好路过x星银行就去换零钱。
  >小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，剩下的当然都是5元面额的。
  >银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗？
  >（5元，2元，1元面额的必须都有，不能是0）
  >
  >输出
  >
  >输出一个整数表示答案

* **解题思路**

  这道题不用跑程序手算也是可以的。跑程序暴力枚举所有情况取最优解的即可。

* **代码**

* **答案**

  $74$

# 第二题 激光样式

* **题面**

  >x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。
  >安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！
  >国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？
  >显然，如果只有3台机器，一共可以成5种样式，即：
  >全都关上（sorry, 此时无声胜有声，这也算一种）
  >开一台，共3种
  >开两台，只1种
  >30台就不好算了，国王只好请你帮忙了。
  >
  >输出
  >
  >输出一个整数表示答案

* **解题思路**

  这道题有三种方法可以解决。第一种方法是二进制暴力枚举。我们知道利用二进制的$0,1$来表示机器的开关。然后从$0$枚举$2^{30}$，判断每一种情况是否满足即可。这种方法太过暴力，一分钟之内可以跑完。第二种方法就是$dfs$枚举，这种方法可以快速的剪枝，代码量也不是很多。而第三种方法就是动态规划递推了，我们可以用$f[i][0],f[i][1]$表示前$i$个，且第$i$位是$0$和$1$的方案数。那么根据这个题目限制我们就可以得到状态转移方程了：$f[i][0]=f[i-1][0]+f[i-1][1],f[i][1]=f[i-1][0]$。最后结果则是$f[30][1]+f[30][0]$。这种做法秒出结果。

* **二进制暴力枚举代码**
* **$dfs$代码**
* **动态规划代码**

* **答案**

  $2178309$

# 第三题 格雷码

* **题面**

  >格雷码是以n位的二进制来表示数。
  >与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。
  >首尾两个数字也要求只有1位之差。
  >有很多算法来生成格雷码。以下是较常见的一种：
  >从编码全0开始生成。
  >当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0）
  >当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。
  >用这个规则产生的4位格雷码序列如下：
  >0000
  >0001
  >0011
  >0010
  >0110
  >0111
  >0101
  >0100
  >1100
  >1101
  >1111
  >1110
  >1010
  >1011
  >1001
  >1000
  >以下是实现代码，仔细分析其中逻辑，并填写划线部分缺少的代码
  >
  >```c++
  >#include <stdio.h>
  >
  >//题目关键如下生成方式：
  >//编码全从0开始。
  >//当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0）
  >//当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。
  >void show(int a,int n)
  >{
  >    //打印格雷码。
  >	int i;
  >	int msk = 1;
  >	for(i=0; i<n-1; i++) msk = msk << 1;
  >	for(i=0; i<n; i++){
  >		printf((a & msk)? "1" : "0");
  >		msk = msk >> 1;
  >	}
  >	printf("\n");
  >} 
  >
  >void f(int n)
  >{
  >	int i;
  >	int num = 1;
  >	for(i=0; i<n; i++) num = num<<1;
  >	
  >	int a = 0;
  >	for(i=0; i<num; i++){
  >		show(a,n);
  >		
  >		if(i%2==0){
  >            //当产生的是第奇数个数的时候，最末位改变。
  >			a = a ^ 1;
  >		}
  >		else{
  >            //当产生的是第偶数个数的时候，先找到最右边的1，再将它左边的数字改变。
  >			//a = _________________________ ; //填空
  >            //x&(-x)取最右边的1.再左移一位与x做与即可。
  >            a = a^((a&(-a))<<1);
  >		}
  >	}
  >}
  >
  >int main()
  >{
  >	f(4);
  >	return 0;
  >}
  >
  >```

* **解题思路**

  上述代码已贴详细注释。

* **答案**、

  `a^((a&(-a))<<1)`

# 第四题 调手表

* **题面**

  > 小明买了块高端大气上档次的电子手表，他正准备调时间呢。
  > 在 M78 星云，时间的计量单位和地球上不同，M78 星云的一个小时有 n 分钟。
  > 大家都知道，手表只有一个按钮可以把当前的数加一。在调分钟的时候，如果当前显示的数是 0 ，那么按一下按钮就会变成 1，再按一次变成 2 。如果当前的数是 n - 1，按一次后会变成 0 。
  > 作为强迫症患者，小明一定要把手表的时间调对。如果手表上的时间比当前时间多1，则要按 n - 1 次加一按钮才能调回正确时间。
  > 小明想，如果手表可以再添加一个按钮，表示把当前的数加 k 该多好啊……
  > 他想知道，如果有了这个 +k 按钮，按照最优策略按键，从任意一个分钟数调到另外任意一个分钟数最多要按多少次。
  > 注意，按 +k 按钮时，如果加k后数字超过n-1,则会对n取模。
  > 比如，n=10, k=6 的时候，假设当前时间是0，连按2次 +k 按钮，则调为2。
  >
  > 输入
  >
  > 两个整数 n, k ，意义如题。
  >  0 < k < n <= 100000
  >
  > 输出
  >
  > 一行一个整数
  > 表示：按照最优策略按键，从一个时间调到另一个时间最多要按多少次。
  >
  > 样例输入
  >
  > ```
  > 5 3
  > ```
  >
  > 样例输出
  >
  > ```
  > 2
  > ```
  >
  > 提示
  >
  > 如果时间正确则按0次。否则要按的次数和操作系列之间的关系如下：
  > 1：+1
  > 2：+1, +1
  > 3：+3
  > 4：+3, +1

* **解题思路**

  > 经典$bfs$模板题，最终状态即是队列为空的时候。

* **代码**

# 第五题 搭积木

* **题面**

  >小明对搭积木非常感兴趣。他的积木都是同样大小的正立方体。
  >在搭积木时，小明选取 m 块积木作为地基，将他们在桌子上一字排开，中间不留空隙，并称其为第0层。
  >随后，小明可以在上面摆放第1层，第2层，……，最多摆放至第n层。摆放积木必须遵循三条规则：
  >规则1：每块积木必须紧挨着放置在某一块积木的正上方，与其下一层的积木对齐；
  >规则2：同一层中的积木必须连续摆放，中间不能留有空隙；
  >规则3：小明不喜欢的位置不能放置积木。
  >其中，小明不喜欢的位置都被标在了图纸上。图纸共有n行，从下至上的每一行分别对应积木的第1层至第n层。
  >每一行都有m个字符，字符可能是‘.’或‘X’，其中‘X’表示这个位置是小明不喜欢的。
  >现在，小明想要知道，共有多少种放置积木的方案。他找到了参加蓝桥杯的你来帮他计算这个答案。
  >由于这个答案可能很大，你只需要回答这个答案对1000000007(十亿零七)取模后的结果。
  >注意：地基上什么都不放，也算作是方案之一种。
  >
  >输入
  >
  >输入数据的第一行有两个正整数n和m，表示图纸的大小。n<=100，m<=100
  >随后n行，每行有m个字符，用来描述图纸 。每个字符只可能是‘.’或‘X’。
  >
  >输出
  >
  >输出一个整数，表示答案对1000000007取模后的结果。
  >
  >样例输入
  >
  >```
  >2 3
  >..X
  >.X.
  >```
  >
  >样例输出
  >
  >```
  >4
  >```
  >
  >提示
  >
  >```cpp
  >成功的摆放有（其中O表示放置积木）：
  >(1)
  >..X
  >.X.
  >(2)
  >..X
  >OX.
  >(3)
  >O.X
  >OX.
  >(4)
  >..X
  >.XO
  >```

* **解题思路**

  这道题

# 第六题 矩阵求和

* **题面**

  >经过重重笔试面试的考验，小明成功进入 Macrohard 公司工作。
  >今天小明的任务是填满这么一张表：
  >表有 n 行 n 列，行和列的编号都从1算起。
  >其中第 i 行第 j 个元素的值是 gcd(i, j)的平方，
  >gcd 表示最大公约数，以下是这个表的前四行的前四列：
  >1 1 1 1
  >1 4 1 4
  >1 1 9 1
  >1 4 1 16
  >小明突然冒出一个奇怪的想法，他想知道这张表中所有元素的和。
  >
  >输入
  >
  >一行一个正整数 n 意义见题。n <= 10^7
  >
  >输出
  >
  >一行一个数，表示所有元素的和。由于答案比较大，请输出模 (10^9 + 7)(即：十亿零七) 后的结果
  >
  >样例输入
  >
  >```
  >4
  >```
  >
  >样例输出
  >
  >```
  >48
  >```
  >
  >