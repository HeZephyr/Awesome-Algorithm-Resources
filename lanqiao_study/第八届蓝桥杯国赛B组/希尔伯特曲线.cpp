#include <stdio.h>
 
long long f(int n, int x, int y) {
    //n代表的是方格矩阵Hn，大小为2^n*2^n
    if (n == 0) return 1;//由于递归到了H0，那么自然为1.
    int m = 1 << (n - 1);//即m=2^(n-1)次方。
    if (x <= m && y <= m) {
        return f(n - 1, y, x);
        //这里表明，如果x和y是属于左下角的子矩阵，那么我们就递归去寻找，由于左下角的子矩阵是顺时针翻转的，那么我们需要更改x和y
    }
    if (x > m && y <= m) {
        //同理，这里则是右下角的子矩阵。根据前面的分析，这道题其实就易解了。注意这个子矩阵是逆时针翻转过来的。
        //如果没有翻转，坐标是(x-m,y)，现在需要翻转，则为(m-y+1,m-(x-m)+1)
        //return 3LL * m * m + f(n - 1, ________________ , m * 2 - x + 1); //  填空
        return 3LL * m * m + f(n - 1, m-y+1 , m * 2 - x + 1); //  填空
    }
    if (x <= m && y > m) {
        //这里为左上角的子矩阵，那么我们需要加上已经过去了的m*m的序号。
        //这里坐标我们是需要更改的，因为我们递归到左上角的Hn-1矩阵了，那么坐标自然要更改。
        return 1LL * m * m + f(n - 1, x, y - m);
    }
    if (x > m && y > m) {
        //这里为右上角的子矩阵，那么我们需要加上已经过去了的2*m*m的序号。
        return 2LL * m * m + f(n - 1, x - m, y - m);
    }
}
 
int main() {
	int n, x, y;
    scanf("%d %d %d", &n, &x, &y); 
    printf("%lld", f(n, x, y));//给定p点的坐标，输出p点的序号。
 
    return 0;
}