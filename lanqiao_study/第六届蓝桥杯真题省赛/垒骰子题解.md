对于这个题目，我们首先要清楚骰子的摆放，由于任意一面朝上的侧面都可以旋转四次，所以一个骰子的摆放方法有$24$种。为了接下来的处理，我们先定义状态，用$f_{ij}$表示已经放置了前$i$个骰子且最上面那个是第$i$个骰子其最上面是值为$j$的面的方案数，用$h_{i(op[j])}$表示值为$i$的面与$op[j]$的面（因为我们都是考虑上面，表示的也都是上面，所以为了方便，我们都用上面来表示，而下面我们可以用一个数组$op$来对应，自然可以用$op[j]$来表示。）是否互斥，若其值为1说明互斥，反之不互斥。 那么不难发现$f_{ij}=\sum_{k=1}^{n}{4\times f_{(i-1)k}\times h_{i(op[j])}}$（前面已经解释了，骰子可以沿着侧面旋转，故需$\times4$）。为了方便，接下来我们再规定一个函数$F_i=\sum_{j=1}^6{f_{ij}}$，故此问题故是在求解$F_n$。而这就是明明白白的动态规划。初始状态为$F_1$，其不受限制，故方案数为$24$。那么其实我们代码就已经可以写出来了。
```c++
for(int i=1;i<=n;i++){
    for(int j=1;j<6;j++){
        //对6个面的放置状态均进行转移。
        for(int k=1;k<6;k++){
            if(!h[j][op[k]]){
                f[i][j]=(f[i][j]+f[i-1][k]*4)%mod
            }
        }
    }
}
```
这样，我们这个题目是不是解决完了呢？我们发现题目中$n$的范围是$1e9$，这样算下来复杂度达到了$1e10$，这明显会超时，所以我们得进行优化。我们现在用数组来表示，由于：
>$F_n={f[n][1]+f[n][2]+f[n][3]+f[n][4]+f[n][5]+f[n][6]}$
***
>$F_{n-1}={f[n-1][1]+f[n-1][2]+f[n-1][3]+f[n-1][4]+f[n-1][5]+f[n-1][6]}$

而这两个像不像一个$n$行$1$列的矩阵，我们就把它们当做矩阵，那么自然可以假设$F_{n-1}\times A = F_{n}$。由矩阵乘法可知，$A$是一个$6$行$6$列的矩阵。所以我们最关键的就是找出这个矩阵。我们仔细观察一下上面的代码，这和我们的矩阵运算有什么区别吗？很显然，这就是在和我们的$A$进行矩阵运算，那么我们这里就可以列出我们矩阵A的构造方法了。如下：
```c++
int a[7][7];
for(int i=1;i<7;i++){
    for(int j=1;j<7;j++){
        if(h[i][op[j]])a[i][j]=0;
        else a[i][j]=4;
        
    }
}
```
构造出矩阵A后，这个题目就变得简单多了，因为$F_n=F_{1}\times A^{n-1}$，而$F_1=(4,4,4,4,4,4)$。我们最后要求的是总方案数，其实也就是将最后得到的矩阵幂各个位置$\times 4$再累加起来。这就是答案。