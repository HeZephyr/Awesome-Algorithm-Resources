/**
  *@filename:树形DP套路
  *@author: pursuit
  *@csdn:unique_pursuit
  *@email: 2825841950@qq.com
  *@created: 2021-05-19 21:21
**/
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 100000 + 5;
const int P = 1e9+7;

//我们首先需要判断一道题是不是树形DP题。即判断数据结构是不是一棵树，再判断是否符合动态规划的要求。如果不是，就需要考虑其他做法了。
//第一步，建树。根据节点数目选择合适的存储结构。
//若n<5000，则可以采用邻接矩阵，反之采用邻接表。
//同样如果是二叉树或者需要多叉转二叉，我们可以用一维数组brother[],child[]来存储特定的树结构。
//第二步，写出动态规划方程。我们需要通过观察孩子和父亲之间的关系来建立转移方程。写法通常有两种：
//1.根到叶子。相当于自顶向下。这种运用情况比较少，因为我们很难确定终止状态。
//2.叶子到根。相当于自底向上。即跟的子节点传递有用的信息给根，逐步得到根的最优解的过程。
//树形DP是没有模板的，很灵活，所以需要足够多的练习掌握，以及一些基础DP需要学习。
void solve(){
}
int main(){
    
    solve();
    return 0;
}